Authoring Environment
=====================
#[Game]
1. Users will be able to save previous sprites and levels created in the Authoring Environment in XML files that are available for reuse when other games are made.
2. **Create a new Game in the Authoring Environment** - Select “New Game” in the MainMenuScreen to create a new Game and XML representation
3. In the Authoring Environment, the user will be able to set up winning conditions. These winning conditions are set up in the Game Engine, so that the Game Engine can check these winning conditions.
4. In the SplashScreen there will be a “Load” button that will allow the user to load previously saved games. This would include game environments as well as games that were previously being played that were paused and saved. These both would load information from the XML file that was saved using XStream.

#[Level]
5. **Create a new Level in the Authoring Environment** -   When the user clicks on the add level menu item, the Authoring Environment will create a blank new Level class and adds the new Level to the GameDisplay. The GameDisplay will then set the Level as the active Level to be displayed.
6. **Saving to file** - Users can save their current game configuration to a file at any point during editing a level or splash screen. This saves the each level, splash screen, and all the sprites (location, image, behaviors) to a series of XML files that can be loaded later to play the game.
7. **Powerups** - The user will be able to implement various items that the player will be able to pick up throughout the game. These can be found on the ground or be dropped by enemies, and can provide benefits such as increased health, power, stamina, etc.
8. **Adding text** - While editing a splash screen or level, the user can add text directly on the screen or to a mini-pop up. Both ways of adding text can be configured for size and font (saved and accessed from a gameStats file which holds data common across levels - so text size and font would most likely be kept constant across levels and splash screens separately). The mini-pop up feature would be a separate sprite behavior interface that can be applied to certain elements - such as powerups - to display some information or instruction to the user.
9. **Player Start Location** - Our Level Editor will allow a user to set a player start location
10. **Enemy Spawn Location** - Our Level Editor will allow a user to configure an automated-spawn location for new enemies.

#[Sprite]
11. **Adding sprite to the Authoring Environment** - When the user clicks in the game area, it will invoke a lambda in the GameDisplay screen that requests the user to select a sprite from a menu. When the menu item is clicked, another lambda will be invoked to create a sprite and add it to the display.
12. **Set properties of sprite in Authoring Environment** - When the user clicks on a sprite in the game area, a lambda will call the an update method on PropertiesDisplay telling it to re-render the display with the properties of the sprite. The properties in the display then bind themselves to the properties in the sprite.
13. **Add behavior to existing sprite** - could be modified through authoring envir. or through in game powerups
14. **Getting a weapon** - Weapons are separate sprites that extend powerups. When the player obtains a weapon, (s)he can attack her surroundings, so the attack() method gets activated. When the weapon collides with an enemy, the appropriate behavior method is called.
15. **Deactivate sprites** - In arbitrary game, sprites may need to disappear from the scene, but also need to be brought back at a different point in time or given a different condition. So sprites will have an ‘active’ flag that dictates whether they should exist in the scene (including getter, setter). A use case for this is if a user wishes to cause all “obstacle” sprites to disappear in a “cheat/easy mode”, then all Sprite objects that are identified as objects (containing ‘obstacle’ behavior) will have ‘’’exampleSprite.setActive(false)’’’ called.
16. **Grouping sprites** - If author wants to group sprites in his/her own way, he can attach a string called a ‘tag’ to them which allows operations to be done to all strings of a certain ‘tag’. To access all objects of specific tag, use level’s ‘’’getSpritesWithTag(String tag)’’’ method (static), which will return an array of sprites.
17. **Behavior loss** - In arbitrary game, sprites may need to lose a certain behavior or function, but need to bring it back later along with the instance variables, so re-instantiation is not an option. As such, behaviors also will have an ‘active’ flag that dictates whether it should function (including getter, setter). A use case for this is if a user wishes to remove all health functionality from the scene, all sprites will have ‘’’exampleSprite.getBehaviorOfType(HealthBehavior).setActive(false)’’’ called.
18. **SpriteImage From Image** - The SpriteEditor will allow a user to add an image to a Sprite as a SpriteImage. SpriteImage is a pixelated version of the image passed, and will allow 
19. **Image From SpriteImage** - Each SpriteImage can be read into the GameEngine. When GameEngine calls SpriteImage.nextImage(), the Sprite appears to be animated while moving.
20. **Rotating While Moving** - GameEngine will reflect the Image resultant from the SpriteImage to reflect either going left or right while moving.

#[Player]
21. Allow users to create a player file when authoring that takes in a series of images.  Each image would be displayed in succession while the game timeline is running/when the player is inputting movement commands in order to simulate movement.  GamePlayer class that has attached javafx objects (or the pixel idea, depending on what we do) could possibly load these images in and switch between them at a user defined pace (ex. user could specify a switch every 10 frames.)

Game Player
===========
22. Scene transition from present scene to winning scene or losing scene. Could be accomplished in a number of ways -> GamePlayer holds an ArrayList of Groups (or scenes) and when winning or losing condition is met, engine signals to game player to swap out scenes -> could do a finite state machine kind of deal: a State class (level 1, level 2, winningState, losingState) that has a pointer to another State, and transitions accordingly
23. A leaderboard will be displayed at the end of a game or level. The GamePlayer will keep track of this score and then will be added to the leaderboard. The leaderboard will be saved as a “.txt document?????? or XML I guess” and displayed after each game or can be checked in the splash screen.

Controls / Keys
===============
24. ** Setting up the link between the key pressed and moving the player** - In the GameEngine class, using xstream, a map<KeyCode, String> is created. The keyBindings are then done by using event handlers to called the appropriate method using reflection based on the string from the map.
25. **Moving the character left and right** - When the key bindings are done in the initialize method. The player is able to move the character left and right by pressing on the appropriate key which then updates the X coordinate of the player. During the game loop, a renderer method is called which updates the view to display the outcome of the player moving in the x-direction.
26. ** Pausing the game** - There would be a button or a key mapped to pausing the game. When it is invoke, GameEngine.pause() would be called which pauses the KeyFrame. To resume the game, the KeyFrame would be resumed using the animation methods.
27. **Key Stroke and movement** - Game designers could setup the player movement by moves only when key is pressed with constant speed. It could also set up by real world mechanics: even when key is released, acceleration determines when it stops moving.



Game Engine
===========
28. **Check winning conditions** for a given level - need to check constantly to see if one of possible winning conditions have been met on back end, ***this is different from allowing player to customize winning conditions in game authoring environment (someone else can do that one)
29. **“Kill”/delete sprites** if given sprite goes too far off screen or health is reduced to 0 (going off screen could also just reduce health to 0) Health may obviously apply to player and enemies, but potentially give blocks “health” as well so they are breakable with a certain number of hits.
30. **Collision detection** -> handled in the gameEngine. A function checkCollide could take in two sprites as arguments, and then return a boolean stating whether those two objects have collided. Iterate through the list of sprites and check whether collision has occurred. If it has, then call the appropriate function (deleteSprite -> transition to winning or losing condition) (this part is still fuzzy as to how to achieve this?)
31. Scene transition from present scene to winning scene or losing scene. Could be accomplished in a number of ways -> GamePlayer holds an ArrayList of Groups (or scenes) and when winning or losing condition is met, engine signals to game player to swap out scenes -> could do a finite state machine kind of deal: a State class (level 1, level 2, winningState, losingState) that has a pointer to another State, and transitions accordingly
32. **Displaying sprites as images during play** - While the user is playing a game, our program is placing a new object and destroying the old one for each sprite every frame. To display the sprite, the Sprite’s makeView method is called, giving an image. It would be too slow to load an image from memory each frame, and it would take up too much space within the Sprite object to store an entire image, so our solution i s that each Sprite will hold the path to its image file, and a separate class, ImageHolder, will hold a String/image map. It will have a method which given a string, will either call a simple get on its map and return an image, or if the key is not in the map, load the corresponding image, put the pair in its map, and return the image.
33. **Making enemies/platforms move along a motion path** - the motion of a Sprite is determined by which Behaviors it has. One of these Behaviors would be MoveWithinRange. Each instance would hold two points, and the object that has this behavior would move back and forth in a line between those two points. In the authoring environment, ideally we would like to allow the user to place a platform/enemy and set its range of motion with two simple clicks (optional: do an orthogonal mode which only lets the user draw straight lines).
34. Making enemies move toward the player: to allow “smart” enemies in a game, we can give the game designer the option to make enemies move towards the player. Another Behavior, MoveTowardPlayer, would calculate the difference in x coordinate between the player and the enemy and make the enemy move in the appropriate direction based on the sign.
35. **Jump** - Game designers could assign different mechanics of jump. 1.) real world mechanics jumps could be implemented where gravity/acceleration effect movement. In this case player/sprite’s speed and position is constantly updated where calculation is done through formulas：vt = v0 +a*t; S = v0*t + 1/2*a*t^2.  2.)constant speed while jumping and designers assign how high and how fast player/sprite jumps. That means a sudden stop at the tip of jump. In the second case, player/sprite speed is always either 0 when idle or stays the same value in motion for each difficulty level and only velocity direction changes. 
36. **Different Attacks** - 1.) collisions with certain sprites: platform with spikes, fireballs;  2.)attack by jumping on top of enemies. only when the enemy’s moves horizontally. If player attack while enemy jumps or moves diagonally, player gets attacked and lose health (?open to different implementations). 
37. Movement of the fireballs are given two different options: projectile or straightline.
38. Add the current score to the scene using the gamePlayer.  Fetch this score from the gameEngine and display it in the scene returned by the gameEngine (not sure if gameEngine should be responsible for stuff like current score, high-scores, play/pause or not, it seems to me like this should be a gamePlayer function.)
39. **Collision between player and enemy** - In the GameEngine class, in the game loop, each time it’s updated we use a helper method to check, for each movable object, whether it has collided (based on checking coordinates) with another object. If a movable object collides, it will delegate the collision handling to a CollisionHandler, which takes in two sprites and uses a table to determine which method to call.

Camera
======
40. **Shifting the camera frame left and right** - boundaries present for camera (cameraLeft, cameraRight, cameraTop, cameraBottom) that shift in accordance with when a user moves. Could possibly specifiy player window (playerWindowLeft and playerWindowRight). If player steps out of player window && camera window has not reached the ends (start and end of level), then shift camera window in corresponding direction.
41. Possible camera shift options in the authoring environment, such as being able to choose between a player centered camera and shift camera by X when player moves to a certain boundary.  Option could possibly be contained in a level object in an XML file, read in by the game engine.
